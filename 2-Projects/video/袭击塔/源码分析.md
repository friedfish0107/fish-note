# 袭击塔源码分析草稿

>最后更新：2025-11-04 00:45

## `net.minecraft.world.entity.raid.Raid`

### `net.minecraft.world.entity.raid.RaiderType`

这里记载了生成袭击时，每一轮袭击会生成哪些袭击者
(此处为基础数量，不包含后面的额外提升)

```java
    static enum RaiderType {
        VINDICATOR(EntityType.VINDICATOR, new int[]{0, 0, 2, 0, 1, 4, 2, 5}),//卫道士
        EVOKER(EntityType.EVOKER, new int[]{0, 0, 0, 0, 0, 1, 1, 2}),//幻魔者
        PILLAGER(EntityType.PILLAGER, new int[]{0, 4, 3, 3, 4, 4, 4, 2}),//掠夺者
        WITCH(EntityType.WITCH, new int[]{0, 0, 0, 0, 3, 0, 0, 1}),//女巫
        RAVAGER(EntityType.RAVAGER, new int[]{0, 0, 0, 1, 0, 1, 0, 2});//劫掠兽
        //以上所有内容从1开始计数(第0项为0，且不使用)

        static final RaiderType[] VALUES;
        final EntityType<? extends Raider> entityType;
        final int[] spawnsPerWaveBeforeBonus;

        private RaiderType(EntityType<? extends Raider> entityType, int[] nArray) {
            this.entityType = entityType;
            this.spawnsPerWaveBeforeBonus = nArray;
        }

        static {
            VALUES = RaiderType.values();
        }
    }
```

### `net.minecraft.world.entity.raid.spawnGroup`

生成袭击小队

```java
private void spawnGroup(BlockPos blockPos) {
        boolean bl = false;
        int n = this.groupsSpawned + 1;
        this.totalHealth = 0.0f;
        DifficultyInstance difficultyInstance = this.level.getCurrentDifficultyAt(blockPos);
        boolean bl2 = this.shouldSpawnBonusGroup();
        for (RaiderType raiderType : RaiderType.VALUES) {
            Raider raider;
            int n2 = this.getDefaultNumSpawns(raiderType, n, bl2) + this.getPotentialBonusSpawns(raiderType, this.random, n, difficultyInstance, bl2);
            int n3 = 0;
            for (int i = 0; i < n2 && (raider = raiderType.entityType.create(this.level)) != null; ++i) {
                if (!bl && raider.canBeLeader()) {
                    raider.setPatrolLeader(true);
                    this.setLeader(n, raider);
                    bl = true;
                }
                this.joinRaid(n, raider, blockPos, false);
                if (raiderType.entityType != EntityType.RAVAGER) continue;
                Raider raider2 = null;
                if (n == this.getNumGroups(Difficulty.NORMAL)) {
                    raider2 = EntityType.PILLAGER.create(this.level);
                } else if (n >= this.getNumGroups(Difficulty.HARD)) {
                    raider2 = n3 == 0 ? (Raider)EntityType.EVOKER.create(this.level) : (Raider)EntityType.VINDICATOR.create(this.level);
                }
                ++n3;
                if (raider2 == null) continue;
                this.joinRaid(n, raider2, blockPos, false);
                raider2.moveTo(blockPos, 0.0f, 0.0f);
                raider2.startRiding(raider);
            }
        }
        this.waveSpawnPos = Optional.empty();
        ++this.groupsSpawned;
        this.updateBossbar();
        this.setDirty();
    }
```

### `net.minecraft.world.entity.raid.Tick`

最重要的部分，整个袭击的逻辑

```java
    public void tick() {
        if (this.isStopped()) {
            return;
        }
        if (this.status == RaidStatus.ONGOING) {
            int n;
            boolean bl;
            boolean bl2 = this.active;
            this.active = this.level.hasChunkAt(this.center);
            if (this.level.getDifficulty() == Difficulty.PEACEFUL) {
                this.stop();
                return;
            }
            if (bl2 != this.active) {
                this.raidEvent.setVisible(this.active);
            }
            if (!this.active) {
                return;
            }
            if (!this.level.isVillage(this.center)) {
                this.moveRaidCenterToNearbyVillageSection();
            }
            if (!this.level.isVillage(this.center)) {
                if (this.groupsSpawned > 0) {
                    this.status = RaidStatus.LOSS;
                } else {
                    this.stop();
                }
            }
            ++this.ticksActive;
            if (this.ticksActive >= 48000L) {
                this.stop();
                return;
            }
            int n2 = this.getTotalRaidersAlive();
            if (n2 == 0 && this.hasMoreWaves()) {
                if (this.raidCooldownTicks > 0) {
                    bl = this.waveSpawnPos.isPresent();
                    int n3 = n = !bl && this.raidCooldownTicks % 5 == 0 ? 1 : 0;
                    if (bl && !this.level.isPositionEntityTicking(this.waveSpawnPos.get())) {
                        n = 1;
                    }
                    if (n != 0) {
                        int n4 = 0;
                        if (this.raidCooldownTicks < 100) {
                            n4 = 1;
                        } else if (this.raidCooldownTicks < 40) {
                            n4 = 2;
                        }
                        this.waveSpawnPos = this.getValidSpawnPos(n4);
                    }
                    if (this.raidCooldownTicks == 300 || this.raidCooldownTicks % 20 == 0) {
                        this.updatePlayers();
                    }
                    --this.raidCooldownTicks;
                    this.raidEvent.setProgress(Mth.clamp((float)(300 - this.raidCooldownTicks) / 300.0f, 0.0f, 1.0f));
                } else if (this.raidCooldownTicks == 0 && this.groupsSpawned > 0) {
                    this.raidCooldownTicks = 300;
                    this.raidEvent.setName(RAID_NAME_COMPONENT);
                    return;
                }
            }
            if (this.ticksActive % 20L == 0L) {
                this.updatePlayers();
                this.updateRaiders();
                if (n2 > 0) {
                    if (n2 <= 2) {
                        this.raidEvent.setName(RAID_NAME_COMPONENT.copy().append(" - ").append(Component.translatable(RAIDERS_REMAINING, n2)));
                    } else {
                        this.raidEvent.setName(RAID_NAME_COMPONENT);
                    }
                } else {
                    this.raidEvent.setName(RAID_NAME_COMPONENT);
                }
            }
            bl = false;
            n = 0;
            while (this.shouldSpawnGroup()) {
                BlockPos blockPos;
                BlockPos blockPos2 = blockPos = this.waveSpawnPos.isPresent() ? this.waveSpawnPos.get() : this.findRandomSpawnPos(n, 20);
                if (blockPos != null) {
                    this.started = true;
                    this.spawnGroup(blockPos);
                    if (!bl) {
                        this.playSound(blockPos);
                        bl = true;
                    }
                } else {
                    ++n;
                }
                if (n <= 3) continue;
                this.stop();
                break;
            }
            if (this.isStarted() && !this.hasMoreWaves() && n2 == 0) {
                if (this.postRaidTicks < 40) {
                    ++this.postRaidTicks;
                } else {
                    this.status = RaidStatus.VICTORY;
                    for (UUID uUID : this.heroesOfTheVillage) {
                        Entity entity = this.level.getEntity(uUID);
                        if (!(entity instanceof LivingEntity) || entity.isSpectator()) continue;
                        LivingEntity livingEntity = (LivingEntity)entity;
                        livingEntity.addEffect(new MobEffectInstance(MobEffects.HERO_OF_THE_VILLAGE, 48000, this.badOmenLevel - 1, false, false, true));
                        if (!(livingEntity instanceof ServerPlayer)) continue;
                        ServerPlayer serverPlayer = (ServerPlayer)livingEntity;
                        serverPlayer.awardStat(Stats.RAID_WIN);
                        CriteriaTriggers.RAID_WIN.trigger(serverPlayer);
                    }
                }
            }
            this.setDirty();
        } else if (this.isOver()) {
            ++this.celebrationTicks;
            if (this.celebrationTicks >= 600) {
                this.stop();
                return;
            }
            if (this.celebrationTicks % 20 == 0) {
                this.updatePlayers();
                this.raidEvent.setVisible(true);
                if (this.isVictory()) {
                    this.raidEvent.setProgress(0.0f);
                    this.raidEvent.setName(RAID_BAR_VICTORY_COMPONENT);
                } else {
                    this.raidEvent.setName(RAID_BAR_DEFEAT_COMPONENT);
                }
            }
        }
    }
```

袭击保存位置:`.\saves\存档\data\raids.dat`
