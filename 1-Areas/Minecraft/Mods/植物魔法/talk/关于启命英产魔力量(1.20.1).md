# 1.20.1中启命英的产魔力的研究

>最后更新：2025-05-06 01:47

先上反编译的源码

```java
// Source code is decompiled from a .class file using FernFlower decompiler.
package vazkii.botania.common.block.flower.generating;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import net.minecraft.core.BlockPos;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import vazkii.botania.api.block_entity.GeneratingFlowerBlockEntity;
import vazkii.botania.api.block_entity.RadiusDescriptor;
import vazkii.botania.api.block_entity.RadiusDescriptor.Rectangle;
import vazkii.botania.common.block.BotaniaBlocks;
import vazkii.botania.common.block.BotaniaFlowerBlocks;
import vazkii.botania.common.block.block_entity.CellularBlockEntity;

public class DandelifeonBlockEntity extends GeneratingFlowerBlockEntity {
   public static final int RANGE = 12;
   public static final int SPEED = 10;
   public static final int OVERGROWN_SPEED = 5;
   public static final int MAX_MANA_GENERATIONS = 100;
   public static final int MANA_PER_GEN = 60;
   private static final String TAG_RADIUS = "radius";
   private int radius = 12;
   private static final int[][] ADJACENT_BLOCKS = new int[][]{{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};

   public DandelifeonBlockEntity(BlockPos pos, BlockState state) {
      super(BotaniaFlowerBlocks.DANDELIFEON, pos, state);
   }

   public int getRange() {
      return this.radius;
   }

   public void tickFlower() {
      super.tickFlower();
      if (!this.m_58904_().f_46443_) {
         if (this.shouldTick(this.m_58904_().m_46467_())) {
            this.runSimulation();
         } else if (this.shouldTick(this.m_58904_().m_46467_() + 1L)) {
            int diameter = this.radius * 2;

            for(int i = 0; i <= diameter; ++i) {
               for(int j = 0; j <= diameter; ++j) {
                  BlockPos pos = this.getEffectivePos().m_7918_(-this.radius + i, 0, -this.radius + j);
                  BlockEntity tile = this.m_58904_().m_7702_(pos);
                  if (tile instanceof CellularBlockEntity) {
                     ((CellularBlockEntity)tile).claim(this);
                  }
               }
            }
         }
      }

   }

   private boolean shouldTick(long gameTime) {
      return (!this.overgrowthBoost && gameTime % 10L == 0L || this.overgrowthBoost && (gameTime + 5L) % 10L == 0L) && this.m_58904_().m_276867_(this.m_58899_());
   }

   private void runSimulation() {
      CellTable table = new CellTable(this.radius, this);
      List<LifeUpdate> changes = new ArrayList();
      boolean wipe = false;

      int adj;
      for(int i = 0; i < table.diameter; ++i) {
         for(int j = 0; j < table.diameter; ++j) {
            int oldLife = table.at(i, j);
            adj = table.getAdjCells(i, j);
            int newLife;
            if (adj == 3 && oldLife == -1) {
               newLife = table.getSpawnCellGeneration(i, j);
            } else if ((adj == 2 || adj == 3) && vazkii.botania.common.block.flower.generating.DandelifeonBlockEntity.Cell.isLive(oldLife)) {
               newLife = oldLife + 1;
            } else {
               newLife = -1;
            }

            int xdist = Math.abs(i - this.radius);
            int zdist = Math.abs(j - this.radius);
            int allowDist = 1;
            if (xdist <= allowDist && zdist <= allowDist && vazkii.botania.common.block.flower.generating.DandelifeonBlockEntity.Cell.isLive(newLife)) {
               if (oldLife == 1) {
                  newLife = -1;
               } else {
                  oldLife = newLife;
                  newLife = -2;
                  wipe = true;
               }
            }

            if (newLife != oldLife) {
               changes.add(new LifeUpdate(i, j, newLife, oldLife));
            }
         }
      }

      LifeUpdate change;
      BlockPos pos_;
      for(Iterator var12 = changes.iterator(); var12.hasNext(); this.setBlockForGeneration(pos_, Math.min(adj, 100), change.oldLife())) {
         change = (LifeUpdate)var12.next();
         pos_ = table.center.m_7918_(-this.radius + change.x(), 0, -this.radius + change.z());
         adj = change.newLife();
         if (adj != -2 && wipe) {
            adj = -1;
         }
      }

   }

   void setBlockForGeneration(BlockPos pos, int cell, int prevCell) {
      Level world = this.m_58904_();
      BlockState stateAt = world.m_8055_(pos);
      BlockEntity tile = world.m_7702_(pos);
      if (cell == -2) {
         if (stateAt.m_60795_()) {
            int val = prevCell * 60;
            world.m_7471_(pos, true);
            this.addMana(val);
            this.sync();
         }
      } else if (tile instanceof CellularBlockEntity) {
         CellularBlockEntity cellBlock = (CellularBlockEntity)tile;
         cellBlock.setNextGeneration(this, cell);
      } else if (vazkii.botania.common.block.flower.generating.DandelifeonBlockEntity.Cell.isLive(cell) && stateAt.m_60795_()) {
         world.m_46597_(pos, BotaniaBlocks.cellBlock.m_49966_());
         tile = world.m_7702_(pos);
         ((CellularBlockEntity)tile).setNextGeneration(this, cell);
         ((CellularBlockEntity)tile).setGeneration(-1);
      }

   }

   public RadiusDescriptor getRadius() {
      return Rectangle.square(this.getEffectivePos(), this.radius);
   }

   public RadiusDescriptor getSecondaryRadius() {
      return Rectangle.square(this.getEffectivePos(), 1);
   }

   public int getMaxMana() {
      return 50000;
   }

   public int getColor() {
      return 10226302;
   }

   public void writeToPacketNBT(CompoundTag cmp) {
      super.writeToPacketNBT(cmp);
      if (this.radius != 12) {
         cmp.m_128405_("radius", this.radius);
      }

   }

   public void readFromPacketNBT(CompoundTag cmp) {
      super.readFromPacketNBT(cmp);
      this.radius = cmp.m_128441_("radius") ? cmp.m_128451_("radius") : 12;
   }
}

```

- `shouldTick`:`!overgrowthBoost||overgrowthBoost`,两侧都分别进行了模10运算，即10t更新一次
- 基础数值:最大魔力存储上限50000,半径12(25*25)

主要函数:`setBlockForGeneration`
调用处:`this.setBlockForGeneration(pos_, Math.min(adj, 100), change.oldLife())`
其中`change`存储了本轮中更新的细胞

测试结论:产魔=同一时刻(进入生产范围的细胞数代数+1)总和*60

对于摆放方式，最优解是同时6个细胞产魔,经历101代(50.5s)产生36360mana,720/s产量e
