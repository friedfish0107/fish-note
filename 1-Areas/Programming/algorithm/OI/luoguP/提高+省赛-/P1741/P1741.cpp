#include<iostream>
using namespace std;

int fro[3000];//标志：其中0代表上方为无意义图形，偶数表示新创矩形，其值的1/2为起始索引，偶数+1，负数代表之后皆无意义
int main(){
	int n;
	cin>>n;
    int f=1;//0:横,1:竖 
    int f1=0;//矩形下半状态0:无状态，-1:矩形开口,n:矩形封口
    int f2=0;//矩形上半状态0:无状态,n:新矩形的编号
    int ans=0;
    for(int j=1;j<n*2+2;j++){
        f^=1;//切换状态
        for(int i=1+1;i<=n+f+1;i++){
            char x;
            cin>>x;
            x-='0';
            if(fro[i]<0){//如果其被标记
                    if(fro[i]==-fro[i+1])fro[i+1]*=-1;//标记下个相同内容
                    fro[i]=0;//回归状态
            }
            if(f==0){//横向
                if(x==0){//如果当前为0
                    //注:头上状态为n or 0，n代表在矩形下方，只有可能是开口开始 or f1状态,0则无需改动
                    if(f1==-1){//且状态位为矩形开口，则代表当前满足延续状态，内容不变
                        if(fro[i]!=fro[i+1])f1=0;//如果矩形已经开口结束，则状态回归
                    }
                    else if(f1==0){//且无特殊状态，则代表其上及后续内容皆为开口
                        if(fro[i]>0){f1=-1;if(fro[i]!=fro[i+1])f1=0;}//如果上方为矩形，则进入开口矩形
                    }
                    else if(f1==1){fro[fro[i]/2]*=-1;f1=0;}//如果其上方有正在封闭的矩形，则代表矩形已无意义，则销毁其
                    
                    if(f2>0){//若当前正在围新矩形
                        f2=0;//停止
                    }
                }
                if(x==1){//如果当前为1
                    //头上状态为n or 0，n代表在矩形下方，闭口开始/f1状态，0无需特殊改动
                    if(fro[i]>0&&f1==0){/*cout<<1;*/f1=1;if(fro[i]!=fro[i+1]){f1=0;ans++;cout<<1;}}//无状态，进入封口
                    else if(f1>0){//封口状态，无特殊变化，检查封口完毕是否
                        if(fro[i]!=fro[i-1]){fro[fro[i]/2]*=-1;fro[fro[i-1]/2]*=-1;}//L型 两个矩形作废
                        if(fro[i]!=fro[i+1]){f1=0;ans++;/*cout<<endl<<j<<" "<<i<<endl;*/}//是则停止检查，答案+1
                    }
                    else if(f1==-1){//开口进垃圾，矩形作废
                        fro[fro[i]/2]*=-1;
                        f1=0;
                    }

                    //必定需要围出新矩形
                    if(f2==0){//新矩形开始
                        f2=i*2;
                    }
                    fro[i]=f2;//若非，则继续
                }
            }
            if(f==1){//竖向
                //if (i==1){cout<<1<<"\t";f2=fro;continue;}//忽略最左侧的1
                
                if(fro[i]==0){//头上为无意义图形
                    //唯一破局情况，此处为前面的图形封口，否则无竖线会让前面的矩形无意义
                    if(x==0){fro[fro[i-1]/2]*=-1;}//无意义图形且未遮挡，使矩形作废
                    if(x==1)f2=0;//遮挡住无意义图形，当前状态不变，连续性破坏
                }
                else if(fro[i]!=0){//头上为有意义图形
                cout<<1;
                    if(x==0){
                        if(fro[i]%2==0){fro[i]=f2;}
                        else if(fro[i]==fro[i-1]){fro[i]=f2;/*cout<<j<<" "<<i<<endl;*/}//无遮挡，与左侧直接连接
                        else {fro[fro[i]/2]*=-1;fro[fro[i-1]/2]*=-1;f2=0;}//L型 两个矩形作废
                    }
                    if(x==1){//被遮挡
                        //三种状态:新矩形开端，新创矩形分列，矩形中间破坏
                        if(fro[i]%2==1 && fro[i]!=fro[i-1]){//新矩形的开始
                            f2=fro[i];//确认连续内容
                        }
                        else if(fro[i]%2==0){//新矩形
                            f2=i*2+1;//此处的开始
                            fro[i]=f2;//同化
                        }
                        else if(fro[i]==fro[i-1]){fro[fro[i]/2]*=-1;f2=0;}//矩形中间，矩形作废
                    }
                }
            }
            if(f==0){
                if(x==1)cout<<"_";
                else cout<<" ";
            }
            if(f==1){
                if(x==1)cout<<"|";
                else cout<<" ";
            }
            cout<<fro[i]/2.0<<"\t";
            
        }
        cout<<endl;
    }
    cout<<ans;
	return 0;
}
/*
 if(fro[i]==0){//如果上方没有待结算的矩形
                    if(fro[i-1]==0)fro[i]=x*i*2;//如果没有需要延续的矩形，且有边，则开创新矩形，内容为当前索引*2
                    else if(fro[i-1]>0)fro[i]=x*fro[i-1];//如果需要延续前面的矩形，则根据当前状态适时延续
                }
                else if(fro[i]>0){//如果上方图形有意义，则延续，或结算
                    if(fro[i-1]!=fro[i]){//如果前文与当前不同，代表其为结算的开始/矩形的延续，视情况延续或结算
                        if(x==1){//当前为结算起始点
                            f1=fro[i];//标志结算
                        }
                        if(fro[i-1]==0)
                        fro[i]=-2*x*fro[i]+fro[i];//如果x=0,则延续，如果x=1，则结算
                    }
                    else if(fro[i-1]==fro[i] && f1==0)fro[i]=-(x-1)*fro[i];//如果为延续状态，不能为1，可以为0
                    else (fro[i-1]==fro[i] && f1>0){//如果为结算状态，只能为1，不能为0,会出现结算完毕和结算失败的情况
                        fro[i]=-x*fro[i];//如果为1
                        if(x==1&&fro[i]!=-fro[i+1]){ans++}
                        if(x==0){}
                    }
                }
*/
